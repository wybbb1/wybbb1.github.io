---
title: 容错框架核心功能
date: 2025-12-28
updated: 2025-12-28
categories: 
  - 实战
---

## 熔断

### 状态
熔断器的行为由三个互斥的状态控制：
- 闭合（Closed）：在这个状态下，熔断器允许所有请求通过，并监控请求的成功和失败情况。
- 开路（Open）：当请求失败率超过设定的阈值时，熔断器进入打开状态，在这个状态下，所有请求都会被立即拒绝，以防止系统过载。
- 半开（Half-Open）：在这个状态下，熔断器允许部分请求通过，以测试系统是否已经恢复。如果这些请求成功率达到一定阈值，熔断器将重新关闭；否则，继续保持打开状态。

为了让状态流转，我们需要一些组件来监控请求的成功和失败情况，并根据设定的阈值来决定何时切换状态。

### 滑动窗口
我们可以很容易地想到通过检查近n次请求的表现来判断是否需要熔断，但是这种做法如果n不够大，可能会导致熔断器变得很敏感，会因为短暂的请求失败而频繁地切换状态。
为了解决以上问题，我们可以在一个固定大小的时间窗口内统计请求的成功和失败情况，这样可以平滑请求的表现，减少熔断器的敏感性。

### 依赖
```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-circuitbreaker</artifactId>
    <!-- 如果是 resilience4j 2 需要 >= JDK17 -->
    <version>${resilience4jVersion}</version> 
</dependency>
```
### 使用
#### 2.1 基础使用示例

```java
// ============ 1. 创建 CircuitBreaker ============
// 使用默认配置: 50% 失败率阈值, 100 次滑动窗口, 60s 等待时间
CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("userService");

// ============ 2. 装饰受保护的函数 ============
Supplier<String> protectedService = CircuitBreaker.decorateSupplier(
    circuitBreaker,
    () -> remoteUserService.getUserById(userId)  // 可能失败的服务调用
);

// ============ 3. 执行调用 ============
try {
    String result = protectedService.get();
} catch (CallNotPermittedException e) {
    // 熔断器打开时的降级处理
    return getCachedUser();
}
```

### 2.2 带降级的完整示例

```java
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.vavr.control.Try;

// 创建配置
CircuitBreakerConfig config = CircuitBreakerConfig.custom()
    .failureRateThreshold(50)                    // 失败率阈值 50%
    .waitDurationInOpenState(Duration.ofSeconds(30)) // 打开后等待 30s
    .permittedNumberOfCallsInHalfOpenState(5)       // 半开状态允许 5 次测试
    .slidingWindow(100, 10, SlidingWindowType.COUNT_BASED) // 滑动窗口配置
    .build();

CircuitBreaker circuitBreaker = CircuitBreaker.of("userService", config);

// 装饰
Supplier<String> decoratedSupplier = CircuitBreaker.decorateSupplier(
    circuitBreaker,
    () -> remoteService.call()
);

// 使用 Vavr 的 Try 进行函数式降级处理
Supplier<Try<String>> supplierWithFallback = () -> {
    try {
        return Try.success(decoratedSupplier.get());
    } catch (CallNotPermittedException e) {
        return Try.success(getFallbackData());  // 降级数据
    } catch (Exception e) {
        return Try.failure(e);
    }
};
// 或者订阅Event
// CircuitBreaker.EventPublisher eventPublisher = circuitBreaker.getEventPublisher();
//         eventPublisher.onSuccess(event -> {
//             System.out.println("Success");
//         }).onError(event -> {
//             System.out.println("Error");
//         });


// 执行
String result = supplierWithFallback.get()
    .recover(throwable -> "Default Value")  // 最终兜底
    .get();
```

### 2.3 异步编程支持 (CompletionStage)

```java
// 装饰 CompletionStage
Supplier<CompletionStage<String>> asyncSupplier = CircuitBreaker.decorateCompletionStage(
    circuitBreaker,
    () -> asyncRemoteService.callAsync()
);

// 执行异步调用
asyncSupplier.get()
    .thenAccept(result -> processResult(result))
    .exceptionally(throwable -> {
        if (throwable instanceof CompletionException) {
            Throwable cause = throwable.getCause();
            if (cause instanceof CallNotPermittedException) {
                return handleCircuitOpen();  // 熔断降级
            }
        }
        return handleGenericError(throwable);
    });
```

### 2.4 事件监听示例

```java
// 监听状态变化和错误事件
circuitBreaker.getEventPublisher()
    .onStateTransition(event ->
        log.info("State changed: {} -> {}",
            event.getStateTransition().getFromState(),
            event.getStateTransition().getToState())
    )
    .onError(event ->
        log.error("Call failed after {}ms: {}",
            event.getElapsedDuration().toMillis(),
            event.getThrowable().getMessage())
    )
    .onCallNotPermitted(event ->
        log.warn("Circuit breaker is OPEN, call not permitted")
    )
    .onSuccess(event ->
        log.debug("Call succeeded in {}ms",
            event.getElapsedDuration().toMillis())
    );
```

### 源码学习
以下使用CLOSED状态为例，其余状态的流程放至<a href="#附录A">附录A</a>
#### 正常调用流程 (CLOSED 状态)
```
[客户端请求]
    │
    ▼
CircuitBreaker.decorateSupplier()   
    │
    ├─ 创建装饰后的 Supplier
    │  └─ return () -> { circuitBreaker.acquirePermission(); ... }
    │
    ▼
circuitBreaker.acquirePermission()  # 获取权限的入口函数(同步版本, 异步版本为 tryAcquirePermission())
    │
    ▼
circuitBreakerStateMachine.acquirePermission()     
    │
    ▼
ClosedState.acquirePermission()  
    │  └─ 直接返回，允许调用
    │
    ▼
[执行业务逻辑] supplier.get()
    │
    ├─ 成功 → circuitBreaker.onResult()
    │   │
    │   ▼
    │  CircuitBreakerStateMachine.onResult()  : 
    │   │
    │   ▼
    │  stateReference.get().onSuccess()
    │   │
    │   ▼
    │  ClosedState.onSuccess()  : 
    │   │
    │   ▼
    │  circuitBreakerMetrics.onSuccess() → 返回 Result
    │   │
    │   ▼
    │  checkIfThresholdsExceeded(result)
    │   │  └─ if (未超阈值) → 保持 CLOSED
    │
    └─ 失败 → circuitBreaker.onError()
        │
        ▼
       handleThrowable()  : 
        │  └─ 检查是否应该记录为失败
        │
        ▼
       ClosedState.onError()  :
        │
        ▼
       circuitBreakerMetrics.onError() → 返回 Result
        │
        ▼
       checkIfThresholdsExceeded(result)
        │  └─ if (超阈值 && isClosed.compareAndSet)
        │      │
        │      ▼
        │   transitionToOpenState()
        │      │
        │      ▼
        │   stateTransition(OPEN, ...)
        │      │
        │      ├─ stateReference.getAndUpdate()
        │      ├─ preTransitionHook()
        │      └─ publishStateTransitionEvent()
```

## 限流

## 重试

## 隔离

## 附录A：其他状态的流程图
#### OPEN 状态转换流程
```
[触发阈值检查]
    │
    ▼
ClosedState.checkIfThresholdsExceeded()  : 593-602
    │
    ├─ if (Result.hasExceededThresholds(result))
    │
    ▼
isClosed.compareAndSet(true, false)
    │
    ▼
publishCircuitThresholdsExceededEvent()
    │
    ▼
transitionToOpenState()
    │
    ▼
stateTransition(OPEN, currentState -> new OpenState(...))
    │
    ├─ StateTransition.transitionBetween(getName(), fromState, OPEN)
    │
    ├─ currentState.preTransitionHook()
    │
    ├─ stateReference.getAndUpdate()  → 创建新的 OpenState 实例
    │
    └─ publishStateTransitionEvent()
         │
         └─ 触发注册的 StateTransition 监听器
```
#### HALF_OPEN 状态探测流程
```
[等待时间过去]
    │
    ▼
OpenState.acquirePermission() 
    │
    ├─ if (clock.instant().isAfter(retryAfterWaitDuration))
    │
    ▼
toHalfOpenState()
    │
    ├─ lock.lock()
    ├─ if (isOpen.compareAndSet(true, false))
    │
    ▼
transitionToHalfOpenState()
    │
    └─ 创建新的 HalfOpenState 实例
         │
         ▼
[后续请求到达]
    │
    ▼
HalfOpenState.acquirePermission() 
    │
    ├─ permittedNumberOfCalls.getAndUpdate(current -> --current)
    │
    ├─ if (counter > 0) → return true
    └─ else → return false (拒绝)
         │
         ▼
    [执行测试请求]
         │
         ├─ 成功率高 → transitionToClosedState()
         └─ 失败率高 → transitionToOpenState()
```